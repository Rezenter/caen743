# caen743

API for CAEN 743 boards for Globus-M2 ThomsonScattering usage.  
Драйвер и API для системы регистрации быстрых сигналов диагностики томсоновского рассеяния (ТР) на основе 
оцифровщиков CAEN V1743.

## Навигация:
- [Идеология](#идеология)
- [Консольный интерфейс](#консольный-интерфейс)
- [Сборка](#сборка)
- [Запуск и использование](#запуск-и-использование)
- [Файл конфигурации](#файл-конфигурации)
- [Структура данных](#структура-данных)
- [Проблемы](#проблемы)
- [Вопросы производителю](#вопросы-производителю)
- [API](#api)
- [Структура программы](#структура-программы)
    - [main](#main)
    - [Fast System](#fast-system)
    - [Crate](#crate)
    - [CAEN743](#caen-743)
    - [Chatter](#chatter)
    - [Config](#config)
    - [Storage](#storage)
    - [MessageQueue](#message-queue)
    - [Stoppable](#stoppable)
    - [Logger](#logger)

***

## Идеология
Данная программа (драйвер) обеспечивает синхронное управление несколькими оцифровщиками V1743 (далее платами), 
подключенными к компьютеру системы сбора (далее компьютеру) оптоволоконными линиями по схеме point-to-point
через контроллер A3818.
Драйвер предоставляет одно сетевое соединение, по которому ожидает команд от клиентов в формате, описанном в 
разделе [API](#api).


Программа предназначена для развёртывания на компьютере диагностики ТР, расположенном в спектральной комнате
непосредственно в стойке диагностики ТР.
Предполагается, что компьютер будет иметь адрес во внутренней подсети диагностики ТР (192.168.10.0).
На время отладки компьютеру назначен адрес 192.168.101.83.
 
Драйвер представляет собой консольную программу, где отображается текущее состояние системы сбора и история
последних событий.
Управление осуществляется исключительно через [API](#api) посредством одного TCP сокета в режиме сервера, имеющего 
порт номер 27015.

Программа разработана по асинхронной схеме, работа с клиентом производится в выделенном потоке.
Распознанные команды передаются в очередь, откуда считываются адресатом.
В случае отсутствия команд от клиентов в течение ??? секунд программа принудительно обрывает данное соединение.

Каждая плата обслуживается собственным потоком 

Конфигурация программы по умолчанию записана напрямую в код в файле [Config.h](/include/Config.h).
При запуске программа пытается прочитать файл d:/data/fastDump/config.json и загрузить из него параметры.
***

## Консольный интерфейс

    TS fast acquisition, revision:0.37-2-d67b207
    loading config... 
    configuration ok. 
    Connected to CAEN with address 0
    Connected to CAEN with address 1
    Connected to CAEN with address 2
    Connected to CAEN with address 3
    System initialised	

Выше приведён пример консоли при запуске и успешном подключении к 4-м платам.

    revision:0.37-2-d67b207
Версия хранится в отдельном файле [version.h](version.h) и состоит из 4х групп:
- основной номер версии, обновляется вручную
- номер модификации, обновляется автоматически после git commit
- номер сборки, обновляется автоматически при каждой сборке, сбрасывается после git commit
- короткая SHA последнего git commit 

## Сборка

(depricated) всё разом (вместе с MDS+) собирается только какой-то странной версией minGW64. 
Архив лежит в папке с установками на компьютере системы сбора.

(new) сейчас для сборки используется cygwin

## Запуск и использование
Пока предлагается запускать исполняемый файл из папки со сборкой: D:\code\caen743\cmake-build-debug\fastAcquisition.exe.
Также возможен запуск из среды разработки CLion.

1. Подать питание на платы CAEN (включить корзину).  
Либо удерживая тумблер On-Off на лицевой панели в верхнем положении, 
либо через программу C:\Program Files (x86)\CAEN\CAENCrateToolBox\CAEN_V8100\Demo\V8100Demo\VME8100_Manager.jar, 
указав следующий IPv4 адрес: 192.168.101.225.  
На нижней панели корзины загорится зелёный индикатор рядом с тумблером. 
На всех платах оцифровщиков загорятся некоторые индикаторы, которые через несколько секунд сменятся на рабочие: 
NIM, зелёный link, pll Lock на ведущей плате и clk in на ведомых.  
Link не будет гореть, пока компьютер системы сбора выключен или не подключено оптоволокно. 
Если состояние индикаторов не приходит к рабочему через несколько секунд после подачи питания, 
возможно, это проблема 1.  
Оставить оцифровщики выходить на температурный режим в течение получаса.
2. Включить компьютер системы сбора.  
Под крышкой на лицевой панели необходимо нажать и отпустить подпружиненный чёрный тумблер.
Логин: ts_group
3. Проверить файл конфигурации системы сбора D:\data\fastDump\config.json  
Если файл отсутствует или некорректен будут использованы настройки по умолчанию.  
Чтение файла производится только при запуске программы.
Если необходимо изменить настройки, программу надо остановить, внести изменения в D:\data\fastDump\config.json
и запустить программу вновь (следующий пункт).
4. Запустить серверную часть ПО: D:\code\caen743\cmake-build-debug\fastAcquisition.exe  
Первой строкой в открывшейся консоли будет версия программы.
Далее следует сообщение о чтении файла конфигурации.
После чего начнётся последовательное подключение к каждой из запрошенных в конфигурации плат.  
Во время установки соединения на текущей плате горит жёлтый link.
При успешном опросе всех плат появляется сообщение «System initialised», иначе – программа завершает работу.
5. Подключиться к серверу с помощью любого клиента.  
На текущий момент создан Python класс [Chatter](/utils/chatter.py), реализующий протокол обмена сообщениями [API](#api). 
Пример использования приведён в файле [control.py](utils/control.py). 
Данный алгоритм устанавливает соединение, 
посылает команду на ожидание триггера и спустя заданный промежуток времени останавливает сбор.  
Также реализован алгоритм для просмотра и стат-обработки полученных данных [viewer](utils/viewer.py).

Штатный режим работы предполагает единовременное выполнение пунктов 1-4. 
После чего можно многократно выполнять подключение клиента или многократно посылать запросы из одного и того же клиента.

...

## Файл конфигурации
Файл структурирован по подсистемам:
- crate
    - caenCount = целочисленное число используемых плат от [1, 5).  
Используются первые caenCount оптоволокон для связи. 
По умолчанию величина = 4.  
Пример применения: для отладки удобно работать с одной платой. 
Значение устанавливается 1, нужная плата подключается к 0му гнезду контроллера на задней панели компьютера. 
Для удобства номера гнёзд соответствуют номерам оптоволокон. 
Нулевой кабель не маркирован (надо исправить!).
- experiment
    - maxAcquisitionTime = положительное число с плавающей точкой, секунды.  
Максимальное время нахождения платы в состоянии ожидания триггера.
Не реализовано в текущей версии!
    - debugCounter = целочисленное, неотрицательное.  
Счётчик отладочных разрядов. 
Не реализовано в текущей версии!
    - plasmaCounter = целочисленное, неотрицательное.  
Счётчик разрядов с плазмой. 
Не реализовано в текущей версии!
    - globusCounter = целочисленное, неотрицательное.  
Последний номер разряда токамака, в котором проводились измерения ТР. 
Не реализовано в текущей версии!
    - isPlasma = {true, false}.  
Следующее измерение с плазмой?
Не реализовано в текущей версии!
- caen
    - recordLength = натуральное число из диапазона [1, 65)*16.  
Число временнЫх точек в одном событии. 
Число не должно превышать 1024 и должно быть кратно 16.
По умолчанию 1024.
    - frequency = {“3.2”, “1.6”, “0.8”, “0.4”}.  
Частота оцифровки в GS/s. 
Величина записывается в виде строковой переменной.
Время между соседними точками оцифровки вычисляется как 1/*frequency* и соответственно равно 
0.3125, 0.625, 1.25 и 2.5 нс.
По умолчанию “3.2”.
    - triggerDelay = натуральное число не более 255.  
Перезапись кольцевого буфера будет остановлена после прихода триггера спустя triggerDelay*16/ frequency. 
Увеличение данного параметра приводит к смещению осциллограммы влево в окне оцифровки.
По умолчанию 18.
    - offset = “HEX”, где HEX = \[0, FFFF\]
Число в шестнадцатеричной системе в строковом представлении.  
![documentation on DC offset](/res/offset.png "Image from CAEN datasheet.")  
Регистры 16-бит ЦАПа, которым задаётся опорный уровень ОУ (почему два выхода???).
Документация говорит, что  
0000 => окно оцифровки от -2.5 до 0,  
7FFF => окно оцифровки от -1.25 до 1.25,  
FFFF => окно оцифровки от 0 до 2.5.  
По умолчанию “6FFF”.
    - triggerThreshold = “HEX”, где HEX = \[0, FFFF\].  
Число в шестнадцатеричной системе в строковом представлении.
Регистры 16-бит ЦАПа, которым задаётся уровень запуска по нулевому каналу.  
Насколько я понимаю, выход ЦАП подаётся на компаратор, 
который сравнивает его с уровнем сигнала после подстройки постоянного смещения *offset*. 
Документация говорит, что  
0000 = +1.25 V,  
7FFF = 0 V,  
FFFF = -1.25 V.  
По умолчанию “7FFF”.
- connection
    - connectionInterval =  неотрицатильное число.  
Время в секундах между попытками установить соединение с клиентом.
Увеличение данного параметра уменьшает скорость установки соединения, 
зато снижает нагрузку на ЦП во время ожидания клиента.
По умолчанию 1.
    - commandTimeout = неотрицательное число.  
Время в миллисекундах между чтениями входного буфера команд от клиента.
Увеличение данного параметра уменьшает скорость реакции, зато снижает нагрузку на ЦП.
По умолчанию 100.
    - connectionDeadTime = неотрицательное число.  
Время жизни соединения в секундах после последнего успешного запроса от клиента. 
Пока клиент не разорвал соединение или не признан «неживым», подключение нового невозможно. 
Если клиент не посылал запросы более чем  connectionDeadTime секунд, соединение принудительно закрывается.
По умолчанию 120.
    - messagePoolingInterval = неотрицательное число.  
Время в миллисекундах между чтениями внутренней очереди сообщений. 
Увеличение данного параметра уменьшает скорость реакции, зато снижает нагрузку на ЦП.
По умолчанию 100.
- storage
    - plasmaPath = “кошерный\виндовский\путь”  
строка с путём (абсолютный работает, относительный – не пробовал) к существующей папке для хранения разрядов с плазмой.
По умолчанию "d:/data/fastDump/plasma/".
    - debugPath = “кошерный\виндовский\путь”  
строка с путём (абсолютный работает, относительный – не пробовал) к существующей папке для хранения отладочных разрядов.
По умолчанию "d:/data/fastDump/debug/".
    - logPath = “кошерный\виндовский\путь”  
строка с путём (абсолютный работает, относительный – не пробовал) к существующей папке для хранения журналов.
По умолчанию "d:/data/fastDump/logs/".
В текущей версии не реализовано!
    - verboseLevel = целое, неотрицательное число.  
Задаёт уровень подробности сообщений в журнале. 
Больше число – больше сообщений.
Не реализовано в текущей версии!


## Структура данных
На каждый разряд в папке plasmaPath или debugPath в зависимости от состояния isPlasma создаётся директория с именем 
номера разряда. 
Ведущими нулями название папки дополняется до пяти символов. 
Проверка, что данные с таким номером разряда уже существуют, не проводится.  

В полученной директории создаётся файл *header.json*, содержащий описание общих для всех плат параметров.
- boards = массив положительных целых чисел.  
Содержит серийные номера плат, участвовавших в данном разряде.
Индекс элемента соответствует порядковому номеру гнезда контроллера A3818 и номеру файла данных.
- error = {true, false}.  
Возникла ли ошибка во время сбора?  
Не реализовано на текущий момент!
- eventLength = натуральное, \[16, 1025).  
Количество оцифрованных ячеек в каждом событии.
- frequency = {“3.2”, “1.6”, “0.8”, “0.4”}.  
Частота оцифровки в GS/s. 
Величина записывается в виде строковой переменной.
Время между соседними точками оцифровки вычисляется как 1/*frequency* и соответственно равно 
0.3125, 0.625, 1.25 и 2.5 нс.
Ширина(длительность) окна оцифровки вычисляется по формуле *eventLength*/*frequency* \[нс\].  

Для каждой из плат из списка *boards* создаётся отдельный файл с именем "d.json", 
где *d* = индекс платы в списке *boards*.
Каждый из этих файлов представляет собой массив событий, зарегистрированных конкретной платой.
Так как в текущей версии диагностики платы запускаются независимо друг от друга, возможна ситуация, 
когда число событий в файлах одного разряда будет отличаться для разных плат.

Каждое событие имеет следующий вид: 
- eventId = натуральное число.  
Порядковый номер события.  
Лучше полагаться именно на этот номер, а не на индекс события в массиве.
Пока неясно, случаются ли у платы перескоки нумерации.
- groups = массив структур.  
Каждая структура описывает "группу" на плате, т.е. пару каналов на едином чипе SAMLONG.
Таким образом, массив имеет не более 8 элементов.


Формат структуры для пары каналов следующий:
- isPresent = {true, false}.  
Опрашивалась ли группа? (можно выкинуть и проверять по наличию ключа).
Дальнейшие поля присутствуют только при утвердительном ответе.
- startCellIndex = целое \[0, 1024).  
Порядковый номер ячейки кольцевого буфера SAMLONG, с которой начинается данная страница данных.
- timestampCounter(TDC) = натуральное число.  
Число 200MHz тактов с момента сброса часов или переполнения регистра (написать разрядность!) памяти до данной страницы.  
Более честная величина, чем *timestamp*.  
Неясно, почему привязка ко времени выполняется для каждого чипа по отдельности.
- timestamp = неотрицательное число с плавающей точкой.
Время в миллисекундах с момента сброса часов или переполнения регистра (написать разрядность!) 
памяти до данной страницы.  
Рассчитывается постфактум из *timestampCounter(TDC)* делением на частоту часов. 
Таким образом, погрешность составляет 0.005 мс, остальные знаки после запятой -- в топку.
- data = массив из двух массивов из *eventLength* чисел с плавающей точкой.  
На каждый канал группы свой массив.
Сам сигнал, но в непонятных единицах: это не разряды АЦП и не милливольты.
- triggerCount = массив из двух целых неотрицательных чисел.  
Неизвестная величина.
Документация ничего не говорит о данном поле.
Значения бывают нулевыми для нулевой группы, по которой производится запуск платы.
(Есть предложение выкинуть это поле, если ему не найдётся применение.) 
- timeSinceLastEvent(timeCounter) = массив из двух целых неотрицательных чисел.  
Неизвестная величина.
В каких она попугаях, нужна ли вообще, почему отдельно для каждого канала?

## Проблемы
1. В каких-то случаях отдельный оцифровщик «зависает».
При перезагрузке индикаторы на нём остаются в первоначальном состоянии: горит TTL и жёлтый индикатор передачи данных по 
оптоволокну.  
Подключение и работа с таким устройством невозможны. 
Чаще других такое поведение наблюдается у крайнего правого оцифровщика (№69).
Возможно, это как-то связано с подключением по оптоволокну. 
Проблема может возникнуть без подключения ПО к плате, соответственно, не связана с ПО.  
lite-версия проблемы возникает с платой 69, если при подаче питания не подключить оптоволокно. 
Соответственно,  для её лечения оптоволокно необходимо подключить.  
Решается проблема перезагрузкой платы. 
Однако, необходим либо длительный (2 минуты?) период без подачи питания, либо безумное везение.

2. Корзина обладает большим пусковым током.  
Подключать вводной кабель питания к сети 220В можно только при выключенном компьютере и другом оборудовании.
Подача питания при включенном компьютере приводит к срабатыванию 16А автомата.

3. Разветвитель для т15 неудобоварим для использования.
Однако какой-то отладочный прибор необходим, например, для проверки линейности каналов.

4. Новый синхронизатор имеет рабочий диапазон +- 1 вольт.
Таким образом автоматически теряется более половины динамического диапазона для канала энергии лазера.

5. Синхроимпульсы не генерируются в 5% случаев на выходе *TRG OUT*.

6. В штатной библиотеке не работают прерывания.  


## Вопросы производителю
- По каждой проблеме требуется ответ.

- Что за попугаи по ординате?
- Что за поле "triggerCount"?
- Другие непонятные поля.
- timestampCounter отличается для каждого чипа или таки нет?
- Как добиться максимального быстродействия?
- Как часто необходимо проводить калибровку?
- Не должен ли гореть индикатор *PLL LOCK* для ведомых плат?
- Как сбросить *timestamp* программно и настроить электрический сброс?
 


## API
Драйвер создаёт TCP сокет в режиме сервера на порте 27015 и ожидает подключение клиента.
Сообщения передаются в виде JSON структур.
Команды передаются в очередь исполнения, соответственно ответы на запросы приходят по мере выполнения команд.

На данный момент реализованы следующие команды:

- Запрос готовности.  


 ```json
     {
        "cmd": "alive"
     }
 ```
В случае готовности системы к работе ответ приходит в следующем виде:
```json
    {
        "cmd": "alive",
        "status": true
    }
```
***
- Перевод во "взведённое" состояние.


```json
    {
        "cmd": "arm",
        "shotn": 81,
        "isPlasma": false
    }
```
Переводит все платы в состояние ожидания триггера: начинается запись в циклический буфер.
При этом на каждой плате должен загореться индикатор *RUN* и жёлтый Link.  

Аргументами являются номер разряда *shotn* и логическая переменная *isPlasma*.
Эти параметры задают место для сохранения данных.

При успешном взводе всех плат ответом на запрос служит
```json 
    {
        "cmd": 'arm',
        "status": True
    }
```
***
- Перевод в состояние ожидания.


```json
    {
        "cmd": "disarm"
    }
```
Останавливает запись кольцевого буфера на всех платах и инициирует сохранение накопленных данных на диск.
Запись файлов занимает большое время, поэтому ответ на данный запрос приходит с большой задержкой.
```json
    {
        "cmd": "disarm", 
        "status": true
    }
```
***
- Остановка драйвера.


```json
    {
        "cmd": "exit"
    }
```
Останавливает работу консольной программы.  
Ответ не следует.  
Не рекомендуется использовать в данной версии.
***
- Закрытие соединения с данным клиентом.


```json
    {
        "cmd": "close"
    }  
```
Закрывает сессию текущего клиента, переводя драйвер в режим ожидания нового подключения.  
Ответ не следует.
***

## Структура программы
Программа разделена на несколько блоков.
Модули созданы на основе стандартных c++ классов с поддержкой инкапсуляции.
Соответственно части программы взаимодействуют только с публичными переменными и функциями друг друга.
Модульный подход позволяет наращивать функционал программы, не затрагивая уже созданный.


### main
[main.cpp](src/main.cpp) является точкой входа.


### Fast System
Клас *FastSystem* описывается файлами [FastSystem.cpp](/src/FastSystem.cpp) и [FastSystem.h](/include/FastSystem.h).
Класс подключается напрямую в [main](#main), где создаётся ровно один экземпляр.

...

### Logger
(not implemented)
